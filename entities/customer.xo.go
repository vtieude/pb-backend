package entities

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"

	"github.com/elgris/sqrl"
)

// Customer represents a row from 'customer'.
type Customer struct {
	ID           int             `json:"ID" db:"id"`                      // id
	CustomerName int             `json:"CustomerName" db:"customer_name"` // customer_name
	Phone        sql.NullInt64   `json:"Phone" db:"phone"`                // phone
	Address      sql.NullFloat64 `json:"Address" db:"address"`            // address
	Active       bool            `json:"Active" db:"active"`              // active
	UpdatedAt    time.Time       `json:"UpdatedAt" db:"updated_at"`       // updated_at
	CreatedAt    time.Time       `json:"CreatedAt" db:"created_at"`       // created_at
	// xo fields
	_exists, _deleted bool
}

type FilterCustomer struct {
	ID           *int             // id
	CustomerName *int             // customer_name
	Phone        *sql.NullInt64   // phone
	Address      *sql.NullFloat64 // address
	Active       *bool            // active
	UpdatedAt    *time.Time       // updated_at
	CreatedAt    *time.Time       // created_at

}

// Apply filter to sqrl Customer .
func (c *Customer) ApplyFilterSale(sqrlBuilder *sqrl.SelectBuilder, filter FilterCustomer) bool {
	if filter.ID != nil {
		sqrlBuilder.Where(sqrl.Eq{"id": filter.ID})
	}
	if filter.CustomerName != nil {
		sqrlBuilder.Where(sqrl.Eq{"customer_name": filter.CustomerName})
	}
	if filter.Phone != nil {
		sqrlBuilder.Where(sqrl.Eq{"phone": filter.Phone})
	}
	if filter.Address != nil {
		sqrlBuilder.Where(sqrl.Eq{"address": filter.Address})
	}
	if filter.Active != nil {
		sqrlBuilder.Where(sqrl.Eq{"active": filter.Active})
	}
	if filter.UpdatedAt != nil {
		sqrlBuilder.Where(sqrl.Eq{"updated_at": filter.UpdatedAt})
	}
	if filter.CreatedAt != nil {
		sqrlBuilder.Where(sqrl.Eq{"created_at": filter.CreatedAt})
	}

	return true
}

// Exists returns true when the Customer exists in the database.
func (c *Customer) Exists() bool {
	return c._exists
}

// Deleted returns true when the Customer has been marked for deletion from
// the database.
func (c *Customer) Deleted() bool {
	return c._deleted
}

// Insert inserts the Customer to the database.
func (c *Customer) Insert(ctx context.Context, db DB) error {
	switch {
	case c._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case c._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO customer (` +
		`customer_name, phone, address, active, updated_at, created_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, c.CustomerName, c.Phone, c.Address, c.Active, c.UpdatedAt, c.CreatedAt)
	res, err := db.ExecContext(ctx, sqlstr, c.CustomerName, c.Phone, c.Address, c.Active, c.UpdatedAt, c.CreatedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	c.ID = int(id)
	// set exists
	c._exists = true
	return nil
}

// Update updates a Customer in the database.
func (c *Customer) Update(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case c._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE customer SET ` +
		`customer_name = ?, phone = ?, address = ?, active = ?, updated_at = ?, created_at = ? ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, c.CustomerName, c.Phone, c.Address, c.Active, c.UpdatedAt, c.CreatedAt, c.ID)
	if _, err := db.ExecContext(ctx, sqlstr, c.CustomerName, c.Phone, c.Address, c.Active, c.UpdatedAt, c.CreatedAt, c.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Customer to the database.
func (c *Customer) Save(ctx context.Context, db DB) error {
	if c.Exists() {
		return c.Update(ctx, db)
	}
	return c.Insert(ctx, db)
}

// Upsert performs an upsert for Customer.
func (c *Customer) Upsert(ctx context.Context, db DB) error {
	switch {
	case c._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO customer (` +
		`id, customer_name, phone, address, active, updated_at, created_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`customer_name = VALUES(customer_name), phone = VALUES(phone), address = VALUES(address), active = VALUES(active), updated_at = VALUES(updated_at), created_at = VALUES(created_at)`
	// run
	logf(sqlstr, c.ID, c.CustomerName, c.Phone, c.Address, c.Active, c.UpdatedAt, c.CreatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, c.ID, c.CustomerName, c.Phone, c.Address, c.Active, c.UpdatedAt, c.CreatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Delete deletes the Customer from the database.
func (c *Customer) Delete(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return nil
	case c._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM customer ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, c.ID)
	if _, err := db.ExecContext(ctx, sqlstr, c.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	c._deleted = true
	return nil
}

// CustomerByID retrieves a row from 'customer' as a Customer.
//
// Generated from index 'customer_id_pkey'.
func CustomerByID(ctx context.Context, db DB, id int) (*Customer, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, customer_name, phone, address, active, updated_at, created_at ` +
		`FROM customer ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, id)
	c := Customer{
		_exists: true,
	}
	qb := sqrl.Expr(sqlstr, id)
	if err := db.QueryRowContext(ctx, &c, qb); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}
