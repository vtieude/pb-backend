package entities

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"time"

	"github.com/elgris/sqrl"
)

// Sale represents a row from 'sale'.
type Sale struct {
	ID         int            `json:"ID" db:"id"`                  // id
	FkUser     int            `json:"FkUser" db:"fk_user"`         // fk_user
	FkCustomer sql.NullInt64  `json:"FkCustomer" db:"fk_customer"` // fk_customer
	FkProduct  sql.NullInt64  `json:"FkProduct" db:"fk_product"`   // fk_product
	Price      float64        `json:"Price" db:"price"`            // price
	Note       sql.NullString `json:"Note" db:"note"`              // note
	SaleStatus NullSaleStatus `json:"SaleStatus" db:"sale_status"` // sale_status
	SaledDate  time.Time      `json:"SaledDate" db:"saled_date"`   // saled_date
	Active     bool           `json:"Active" db:"active"`          // active
	UpdatedAt  time.Time      `json:"UpdatedAt" db:"updated_at"`   // updated_at
	CreatedAt  time.Time      `json:"CreatedAt" db:"created_at"`   // created_at
	// xo fields
	_exists, _deleted bool
}

type FilterSale struct {
	ID         *int            // id
	FkUser     *int            // fk_user
	FkCustomer *sql.NullInt64  // fk_customer
	FkProduct  *sql.NullInt64  // fk_product
	Price      *float64        // price
	Note       *sql.NullString // note
	SaleStatus *NullSaleStatus // sale_status
	SaledDate  *time.Time      // saled_date
	Active     *bool           // active
	UpdatedAt  *time.Time      // updated_at
	CreatedAt  *time.Time      // created_at

}

// Apply filter to sqrl Sale .
func (s *Sale) ApplyFilterSale(sqrlBuilder *sqrl.SelectBuilder, filter FilterSale) bool {
	if filter.ID != nil {
		sqrlBuilder.Where(sqrl.Eq{"id": filter.ID})
	}
	if filter.FkUser != nil {
		sqrlBuilder.Where(sqrl.Eq{"fk_user": filter.FkUser})
	}
	if filter.FkCustomer != nil {
		sqrlBuilder.Where(sqrl.Eq{"fk_customer": filter.FkCustomer})
	}
	if filter.FkProduct != nil {
		sqrlBuilder.Where(sqrl.Eq{"fk_product": filter.FkProduct})
	}
	if filter.Price != nil {
		sqrlBuilder.Where(sqrl.Eq{"price": filter.Price})
	}
	if filter.Note != nil {
		sqrlBuilder.Where(sqrl.Eq{"note": filter.Note})
	}
	if filter.SaleStatus != nil {
		sqrlBuilder.Where(sqrl.Eq{"sale_status": filter.SaleStatus})
	}
	if filter.SaledDate != nil {
		sqrlBuilder.Where(sqrl.Eq{"saled_date": filter.SaledDate})
	}
	if filter.Active != nil {
		sqrlBuilder.Where(sqrl.Eq{"active": filter.Active})
	}
	if filter.UpdatedAt != nil {
		sqrlBuilder.Where(sqrl.Eq{"updated_at": filter.UpdatedAt})
	}
	if filter.CreatedAt != nil {
		sqrlBuilder.Where(sqrl.Eq{"created_at": filter.CreatedAt})
	}

	return true
}

// Exists returns true when the Sale exists in the database.
func (s *Sale) Exists() bool {
	return s._exists
}

// Deleted returns true when the Sale has been marked for deletion from
// the database.
func (s *Sale) Deleted() bool {
	return s._deleted
}

// Insert inserts the Sale to the database.
func (s *Sale) Insert(ctx context.Context, db DB) error {
	switch {
	case s._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case s._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	s.UpdatedAt = time.Now()
	s.CreatedAt = time.Now()
	s.Active = true
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO sale (` +
		`fk_user, fk_customer, fk_product, price, note, sale_status, saled_date, active, updated_at, created_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`
	// run
	logf(sqlstr, s.FkUser, s.FkCustomer, s.FkProduct, s.Price, s.Note, s.SaleStatus, s.SaledDate, s.Active, s.UpdatedAt, s.CreatedAt)
	res, err := db.ExecContext(ctx, sqlstr, s.FkUser, s.FkCustomer, s.FkProduct, s.Price, s.Note, s.SaleStatus, s.SaledDate, s.Active, s.UpdatedAt, s.CreatedAt)
	if err != nil {
		return logerror(err)
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return logerror(err)
	} // set primary key
	s.ID = int(id)
	// set exists
	s._exists = true
	return nil
}

// Update updates a Sale in the database.
func (s *Sale) Update(ctx context.Context, db DB) error {
	switch {
	case !s._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case s._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	s.UpdatedAt = time.Now()
	// update with primary key
	const sqlstr = `UPDATE sale SET ` +
		`fk_user = ?, fk_customer = ?, fk_product = ?, price = ?, note = ?, sale_status = ?, saled_date = ?, active = ?, updated_at = ?, created_at = ? ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, s.FkUser, s.FkCustomer, s.FkProduct, s.Price, s.Note, s.SaleStatus, s.SaledDate, s.Active, s.UpdatedAt, s.CreatedAt, s.ID)
	if _, err := db.ExecContext(ctx, sqlstr, s.FkUser, s.FkCustomer, s.FkProduct, s.Price, s.Note, s.SaleStatus, s.SaledDate, s.Active, s.UpdatedAt, s.CreatedAt, s.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the Sale to the database.
func (s *Sale) Save(ctx context.Context, db DB) error {
	if s.Exists() {
		return s.Update(ctx, db)
	}
	return s.Insert(ctx, db)
}

// Upsert performs an upsert for Sale.
func (s *Sale) Upsert(ctx context.Context, db DB) error {
	switch {
	case s._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO sale (` +
		`id, fk_user, fk_customer, fk_product, price, note, sale_status, saled_date, active, updated_at, created_at` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`fk_user = VALUES(fk_user), fk_customer = VALUES(fk_customer), fk_product = VALUES(fk_product), price = VALUES(price), note = VALUES(note), sale_status = VALUES(sale_status), saled_date = VALUES(saled_date), active = VALUES(active), updated_at = VALUES(updated_at), created_at = VALUES(created_at)`
	// run
	logf(sqlstr, s.ID, s.FkUser, s.FkCustomer, s.FkProduct, s.Price, s.Note, s.SaleStatus, s.SaledDate, s.Active, s.UpdatedAt, s.CreatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, s.ID, s.FkUser, s.FkCustomer, s.FkProduct, s.Price, s.Note, s.SaleStatus, s.SaledDate, s.Active, s.UpdatedAt, s.CreatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	s._exists = true
	return nil
}

// Delete deletes the Sale from the database.
func (s *Sale) Delete(ctx context.Context, db DB) error {
	switch {
	case !s._exists: // doesn't exist
		return nil
	case s._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `UPDATE sale SET active = false, updated_at = ? WHERE id = ?`
	// run
	logf(sqlstr, s.ID)
	if _, err := db.ExecContext(ctx, sqlstr, time.Now(), s.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	s._deleted = true
	return nil
}

// SaleByFkCustomer retrieves a row from 'sale' as a Sale.
//
// Generated from index 'fk_customer'.
func SaleByFkCustomer(ctx context.Context, db DB, fkCustomer sql.NullInt64) ([]*Sale, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, fk_user, fk_customer, fk_product, price, note, sale_status, saled_date, active, updated_at, created_at ` +
		`FROM sale ` +
		`WHERE fk_customer = ?`
	// run
	logf(sqlstr, fkCustomer)
	// process
	var res []*Sale
	qb := sqrl.Expr(sqlstr, fkCustomer)
	if err := db.QueryContext(ctx, &res, qb); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// SaleByFkProduct retrieves a row from 'sale' as a Sale.
//
// Generated from index 'fk_product'.
func SaleByFkProduct(ctx context.Context, db DB, fkProduct sql.NullInt64) ([]*Sale, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, fk_user, fk_customer, fk_product, price, note, sale_status, saled_date, active, updated_at, created_at ` +
		`FROM sale ` +
		`WHERE fk_product = ?`
	// run
	logf(sqlstr, fkProduct)
	// process
	var res []*Sale
	qb := sqrl.Expr(sqlstr, fkProduct)
	if err := db.QueryContext(ctx, &res, qb); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// SaleByFkUser retrieves a row from 'sale' as a Sale.
//
// Generated from index 'fk_user'.
func SaleByFkUser(ctx context.Context, db DB, fkUser int) ([]*Sale, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, fk_user, fk_customer, fk_product, price, note, sale_status, saled_date, active, updated_at, created_at ` +
		`FROM sale ` +
		`WHERE fk_user = ?`
	// run
	logf(sqlstr, fkUser)
	// process
	var res []*Sale
	qb := sqrl.Expr(sqlstr, fkUser)
	if err := db.QueryContext(ctx, &res, qb); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// SaleByID retrieves a row from 'sale' as a Sale.
//
// Generated from index 'sale_id_pkey'.
func SaleByID(ctx context.Context, db DB, id int) (*Sale, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, fk_user, fk_customer, fk_product, price, note, sale_status, saled_date, active, updated_at, created_at ` +
		`FROM sale ` +
		`WHERE id = ?`
	// run
	logf(sqlstr, id)
	s := Sale{
		_exists: true,
	}
	qb := sqrl.Expr(sqlstr, id)
	if err := db.QueryRowContext(ctx, &s, qb); err != nil {
		return nil, logerror(err)
	}
	return &s, nil
}

// User returns the User associated with the Sale's (FkUser).
//
// Generated from foreign key 'sale_ibfk_1'.
func (s *Sale) User(ctx context.Context, db DB) (*User, error) {
	return UserByID(ctx, db, s.FkUser)
}

// Product returns the Product associated with the Sale's (FkProduct).
//
// Generated from foreign key 'sale_ibfk_2'.
func (s *Sale) Product(ctx context.Context, db DB) (*Product, error) {
	return ProductByID(ctx, db, int(s.FkProduct.Int64))
}

// Customer returns the Customer associated with the Sale's (FkCustomer).
//
// Generated from foreign key 'sale_ibfk_3'.
func (s *Sale) Customer(ctx context.Context, db DB) (*Customer, error) {
	return CustomerByID(ctx, db, int(s.FkCustomer.Int64))
}
